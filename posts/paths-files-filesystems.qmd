---
title: Paths, Files, and Filesystems, Oh My!
author: Zach Duey
date: 2/20/2023
categories:
    - software development
draft: true
toc: true
---

# Introduction

Everyone who writes codes -- software engineers, data engineers, data scientists, etc. -- works with files. Often these files are stored on the user's local machine, but these days, they are just as likely to be stored in remote storage systems like S3, Dropbox, FTP servers, and more. It is common practice to work with files on the local filesystem[^1] for development and debugging purpose and then leverage remote data storage systems when code is running in production. Ideally, this transition would require minimal to no code changes. However, writing portable file management code is complicated by the fact that the libraries for interacting with file-like objects in different storage systems have wildly differing interfaces and functionality. As with most problems in computer science, one solution is to introduce a layer of abstraction; in this case, a generic filesystem interface.

In this post, we will work towards designing a filesystem interface that satisfies these three core requirements. This is largely a pedagogical exercise designed to both learn about file management topics and the challenge of constructing a well-designed interface. For more details about why I am writing this post and how it developed, check out the [history](#history) section. If you are short on time, check out the [tl;dr](#tldr) version.

A generic filesystem interface has three essential features. First, it must be flexible enough to abstract over the underlying differences between data storage systems. Second, it must include all essential filesystem management operations. Finally, it should adhere to the principle of least surprise: most users should find the interface intuitive.

First, we will cover some [background material](#background) about data storage systems and associated concepts. Second, we will enumerate the [essential operations](#essential-operations) that our interface must include. Third, we will take a look at [existing solutions](#prior-art) to the problem. Finally, we will provide a sketch of our [ideal interface](#ideal-interface).

# Background

Data storage is a broad topic that is far beyond the scope of this post, so we will focus on a few key terms and related topics[^2] necessary to design a generic filesystem interface.

A **data storage system** provides the infrastructure to store and manage digital data. A **physical storage device** is the hardware component of this system. Hard drives, solid state drives, flash drives, and SD cards are all examples of physical storage devices. A **filesystem** manages access to and manipulation of data associated with files. A **file** is a collection of _logically_ related data. The data associated with the file may be physically dispersed on the underlying physical storage device. In this way, a file is an abstraction provided by many data storage systems that hides the messy details of exactly how and where the data are stored from the user of that data. A **path** is the _logical_ location of the file within the filesystem. Like a file, a path is an abstraction provided by the system to shield the user of the system from details that are not their concern. Finally, I will abuse terminology a bit and use the term **storage system** to refer to any combination of these elements. With our working definitions laid out, we can now take a look as some of the characteristics that distinguish different storage systems. Ultimately, our interface must be able to abstract away these difference, so understanding them at least at a high level is essential.

The most important difference between storage systems, at least for our purpses, has to do with whether data are stored locally or remotely[^3]. A **local data storage system** persists data on a physical storage device that is _physically_ connected to an individual's computer. In contrast, a **remote data storage system** persists data on a physical storage device that is accessible from, but not physically connected to, an individual's computer. In a remote data storage system, an external computer used to access the system is called a **client**. There are a plethora of remote storage systems that fall into this category including Network Attached Storage (NAS), Dropbox, OneDrive, Box, Google Drive, and many more. One thing that each of these systems have in common is that, to the client, files can be stored and accessed in a similar way as files on the local filesystem. Some remote storage systems even provide a way to _mount_ the filesystem onto the local filesystem such that accessing and managing files on the remote system is identical to working with local files. However, other remote data storage systems do not maintain the same logical similarity to the local storage system: FTP servers and cloud-based blob storage (e.g. S3) are two examples. 

The second differentiator between storage systems revolves around _how_ data are stored. There are three aspects to how data are stored that we will consider: type of data storage, the organizational structure of the filesystem, and whether storage is centalized or distributed.

There are three main types of data storage: file , object, and block storage. The methods used to store and access data for each type of storage system are optimized for different purposes. For example, they differ in how logically-related data are arranged on the underlying physical storage device(s).manifested in how the system physically arranges logically-related data on the underlying physical storage device. **Block storage** is most commonly used for storing data in relational database systems. **Object storage** is frequently used in cloud storage systems like AWS S3, Azure Blob Storage, and GCP object storage. **File storage** is the most common type of storage as it is used for individual computers and the kinds of remote storage systems used by typical consumers (e.g. Dropbox, Box, OneDrive, Google Drive, etc.). We will focus on file and object storage systems as both allow access to logically-related data through file-like objects. One of the challenges we will face in designing our system is ensuring that it abstracts over the differences between these two types of systems in a way that feels both familiar and does not neglect any essential features.

The second way that storage systems diverge is around the _logical_ organizational structure used. The two main types of organizational structures are hierarchical and flat. A **hierarchical organizational structure** introduces an additional abstraction called a directory (or folder), which is a logical container that may contain other directories or files. The vast majority of storage systems leverage a hierarchical organizational structure. In contrast, a **flat organizational structure** keeps all files at a single logical level with the file name used to differentiate objects. Object storage (e.g. AWS S3) often appears to be hierarchical (e.g. directories or folder creation are supported) from the provided UIs, but typically use a flat organizational structure under the hood.

Third, data storage systems may be centralized or distributed. A **centralized data storage system** persists file data in a single physical location. A system that replicates data across multiple physical storage devices connected to a single server is still a centralized data storage system (e.g. single server with physical storage devices arranged in a RAID configuration). In contrast, a **distributed data storage system** stores data on multiple machines. Cloud-based object storage, the Hadoop Distributed File System (HDFS), and many others are distributed storage systems. It is not always the case that remote storage systems are distributed and local storage systems are centralized. For example, an FTP server is a remote data storage system that is also centralized system.

The third differentiator between storage systems has to do with the guarantees offered by the associated filesystem. Many filesystems allow data to be accessed concurrently (via threads, processes, or multiple client machines) and guarantee strong consistency, which means that any read operation will return the latest data. For example, both S3 and POSIX-compatible filesystems[^4] offer strong consistency guarantees. However, some distributed storage system offer a weaker guarantee called eventual consistency. The difference between consistency or other types of guarantees is not important. For our purposes, what is important is that our interface hides these differences from the user.

The final differentiator between storage systems involves the filesystem semantics. To illustrate what I mean, let's consider the difference between files in the generic sense and files managed by a computer's operating system (OS files). On a single computer, the local filesystem is itself managed by the host operating system. However, the filesystem component of many data storage systems are not fundamentally managed by a host operating system. These perating system files often have a particular set of semantics that are not shared by all storage systems. For example, on many *Nix[^5] systems, OS files are managed via file descriptors, which are a unique identifier for a file. Moreover, other operating systems have different semantics for working with files and paths. As another example, Windows uses backslashes to separate path components, while *Nix systems use forward slashes. Our interface should support managing both types of files (generic and OS) without imposing the semantics associated with one onto the other.


# Essential Operations

While the particular requirements of our interface are important, there are a few broader principles to how it should be designed that we have mentioned already and that bears repeating. The overarching motivation for designing our file system library is to faciliate writing portable code. The guiding design principle is that the interface should be unsurprising. Said differently, the library should be easy to use, feel familiar, and just make sense. We will get to _how_ to achieve these goals in the implementation section, but for now we will zoom in one level and look at the broad set of requirements the interface must meet.

Our brief exploration of storage systems surfaced three areas where storage systems differ that our library must abstract away: where the data are stored, how the data are stored, and how stored data are managed. Abstracting away these three sets of differences is the core requirement of our library. However, to make things more concrete, there are four categories of storage systems that we would like our library to support: local file storage managed by different operating systems, cloud-based blob storage, remote file systems, and file _formats_ that can be thought of as self-contained hierarchical file systems. A few common examples inldue zip files tarballs, and files stored using the hierarchical data format (HDF5). With these broader requirements in mind, we can now zoom in one more layer to the specific features that we would like the library to support.

As we think about features, there are three ways to classify them: essential vs. optional, common vs. specific, and by the component, to which, they are associated. We will go through the essential and non-essential features for each of the components that our interface will manage: files, directories, and paths.

## Files

There are the 4 essential file management operations:

1. Create
2. Read
3. Write
4. Delete

This list may surprise you as it excludes some features that you may have expected:

1. Update
2. Move
3. Rename
4. Copy

These operations were left off because, although it may be less efficient, they can be accomplished using the four core operations. In particular, each of the noted non-essential operations can be achieved by reading the file's contents into a temporary location not managed by the interface, removing the old file, creating a new file, optionally manipulating the in-memory data, and then writing the data to the new file. While these operations are not technically essential, it would probably surprise most users to have them as core features. Given our guiding design principle, it would make sense to include these common, but non-essential, operations in our interface.

There are two other common file manipulation features that we have left out thus far:

1. Partial read
2. Partial write

As with the other non-essential features, you can achieve a similar behavior using the core operations. To partially read, you would need to read all data into a temporary location and then read the contents that you want from that location. Partial writes are similar, except that you would update the content outside of the file management interface before writing it back to a file using the interface. Not having the ability to perform partial reads and writes is likely also going to be surprising, which is a point in favor of including it in the core interface. However, not all storage systems natively support random access, which is an essential underlying operation for partially reading and writing to a file and therefore a mark against including these operations in the core interface. We will return to this decision later. 

## Directories

Directory management is essential for hierarchical storage systems, but since not all storage systems are hierarchial, it should not be part of the core interface. We will think about this more in the implementation section, but for now it suffices to think of our file management interface as likely containing multiple layers of interfaces. The features that are both essential and common belong to the core interface. Directory management features belong to the interface shared by all _hierarchical_ storage systems. For such systems, there are three essential operations:

1. Create
2. Read (list contents)
3. Delete (can be recursive)

Much like for file manipulation, there are a few not-technically-essential operations that should probably be part of the standard interface:

1. Move
2. Copy

To keep the interface for hierarchical storage systems unsurprising, it is probably best for us to include these operations in the interface.

## Path

A path is the location of a file in filesystem. Interestingly, you can make the case that there are no essential features for paths since they can be represented with a standard type (e.g. string) in most programming languages. There are any number of nice-to-have features that one might imagine being associated with a path: extracting relevant parts (extension, file name, etc), combining, standdarding, and more. However, we will defer any more details until after exploring how different programming languages handle paths, as well as other abstractions related to file management, in the following section.

# Prior Art

As we turn our attention away from what operations our interface should support to how the interface should be designed, it will be instructive to look at how other similar libraries have been designed. One thing we will see is that programming languages provide widely varying interfaces for interacting with local files. For each of the programming languages we consider, we will be focusing on three essential questions:

1. What are the main abstractions provided by the interface?
2. What operations are available and with which abstraction are they associated?
3. What are the design considerations surfaced by the implementation?

At the end of the tour, we will have surfaced both a menu of implementation options and identified some of the core decisions that go into designing a file management interface.

### Rust

The rust standard library provides the [`std::fs`](https://doc.rust-lang.org/std/fs/index.html#) module for performing file system manipulations and the [`std::path`](https://doc.rust-lang.org/std/path/index.html) module for working with paths.

A [`std::path::Path`](https://doc.rust-lang.org/beta/std/path/struct.Path.html) is an immutable reference to a file in the underlying file system. It can be constructed from a string, abstracts over differences between Unix and Windows path representations, and provides helpful methods for both inspecting information about the path and its components. The abstraction does _not_ provide any methods for manipulating the underlying file. However, it does provide a number of methods that result in calls to the underlying operating system to inspect the referenced file:

- `exists`
- `is_dir`
- `is_file`
- `is_symlink`
- `metadata`
- `read_dir`
- `read_link`
- `symlink_metadata`
- `try_exists`

While these methods are convenient, they go against the implementation implied by our definition, in which a path had no responsibilities or knowledge of the referenced file. The definition implies that these actions fall under the purview of the file system, not a path. This brings us to our first design consideration: the tradeoff between convenience and surprise. Strict conformity to the interfaces implied by the definitions results in a less surpising interface. However, this comes at the expense of convenience as it may require more entities (e.g. path and file system) to perform an operation like checking if the file referenced by a path exists. The requirement that the interface be unsurprising does not preclude making some decisions in favor of convenience, but it does push us to favor a more strict conformity that maintains at least some distinction in responsibilities. Keeping this trade off in mind, let's get back to our exploration of how Rust solves the file management problem.

The [`std::fs`](https://doc.rust-lang.org/std/fs/index.html) serves as both a filesystem abstraction and container for other abstractions supporting file management. The module-level functions include operations for managing files, directories, and their associated permissions. While some of these operations are unique, others overlap with the methods attached to other abstractions. Only the filesystem abstraction includes operations for copying, renaming, and removing files. The `fs` module is also solely responsible for directory management operations. Both [`std::fs::File`](https://doc.rust-lang.org/beta/std/fs/struct.File.html) and `fs` have the ability to manage file data as well as permissions. The data manipulation functionality associated with `fs` is limited to entire contents of the file, whereas the `File` abstraction allows for reading and writing to aribtrary locations. There is also overlap in functionality between the `fs` module and the `Path` abstraction: `canonicalize`, `try_exists`, `read_link`, `read_dir`, and `symlink_metadata` are all equivalent operations available through both abstractions.

Our exploration of the file management abstractions in Rust raises our second design consideration: to what extent should different abstractions have overlapping operations? On the one hand, strict adherence to our definitions of files, paths, and filesystems suggests that each has distinct, non-overlapping operations. On the other, having overlapping functionality may simplify certain tasks by requiring fewer abstractions. This is reminiscent of the convenience vs. surprise tradeoff noted earlier, but we will treat it as a separate consideration because it is a more specific instance of that broader consideration.

## Nodejs

File managment in NodeJS shares many similarities with Rust, but offers two insightful differences: the file system acccepts URLs in addition to file paths, and paths are handled in a totally different way. The two modules relevant to our discussion are [`fs`](https://nodejs.org/api/fs.html) and [`path`](https://nodejs.org/api/path.html)). While the similarities between Rust and NodeJS are interesting, we will foucs our attention on their differences in order to avoid recapitulating the design considerations we have previously discussed.

Nodejs takes a very different approach to paths, which can be condensed into two main differences. First, Nodejs does not have a dedicated `Path` abstraction; instead, the `path` module provides a functional interface that offers a similar set of operations as the `Path` abstraction in Rust. For example, the properties (directory, root, base, name, and extenion) associated with paths are accessed by [parsing](https://nodejs.org/api/path.html#pathparsepath) the string representation of the path. Canonicalizig, normalizing, combining, and other path operations are all performed via functions that take a base path as the first argument. In some ways, this is more of a stylistic difference than a major design consideration. In any programming language that supports both functions and classes as first-class citizens, it is often possible to replace a class with a collection of functions sharing the same first argument. Likewise, a collection of functions operating on the same entity can be conversted into a class with a corresponding set of methods. As a rule of thumb, I prefer pure functions over stateful classes and will reach for a class when doing so offers something that is either not possible with functions, or is unwieldy. In this particular case, the NodeJS design raises the question: is a separate `Path` abstraction necessary? We will leave any further consideration to later when get get arond to designing our interface. The second difference between NodeJS and Rust is more consequential. Unlikke Rust, the NodeJS `path` module does not include any operations that result in calls to the underlying operating system. This implementation is closer to the one implied by our definition of a path and can therefore be seen as yet another manifestation of the convenience vs. surprise tradeoff. In fact, this tradeoff underlies all of our design decisions around which operations to associate with which abstractions.

The most interesting feature of the NodeJS `fs` module relative to Rust is that NodeJS supports providing file names as either a string or `URL` (via the `file:///` syntax). While this may seem surprising at first glance, both URLs and paths represent the location of a resource, and are therefore logically similar. This feature of NodeJS raises two interesting questions. First, should our file management interface support paths represented as URLs? Since URLs can encode more information than paths (protocol, query parameters, basic authentication, etc.), one can make the case that URLs should not be supported, and instead users should be required to convert their URL to a path (or string, depending on our other design decisions). Second, should static web servers be consider another hierarchical data storage system? Neither of these questions are necessarily new design considerations; however, both surface potential features of our library.

## Go

Go is the only programming language that we will discuss that addressses the distinction between generic files and files managed by an operating system. In Go, this distinction is present in both the path and file system abstractions. A generic [path](https://pkg.go.dev/path) is a reference to a location. Generic paths are marked by the use of forward slashes to separate components, which means URLs are natively supported. None of the operations in the `path` package require calls to the underlying storage system. The functionality for working with OS paths lives in the [path.filepath](https://pkg.go.dev/path/filepath) package. This package offers all of the same operations as the `path` package, plus some additional OS path specific operations. Much like the `path` package in Rust, the `path.filepath` package includes a few operations that require calls to the underlying operating system. Two of these operations are also new for us: globbing, and walking. Globbing refers to an operation that searches a given directory for any files matching a particular pattern. Walking involves navigating a file tree and performing some user-defined operation each time a directory or file is encountered. These two operations are features that are worth considering adding to our library, although, we will need to decide -- like all other operations -- which abstraction(s) they should be associated with. Go elects to add them to both the path and file system abstractions.

The file system abstraction in Go is also divided into the [`os`](https://pkg.go.dev/os) package for OS-managed files and the [`fs`](https://pkg.go.dev/io/fs) package for generic file system management. The two packages have many overlapping pieces of functionality, although the `os` package contain additional functionality beyond file mmanagement.

The split interfaces,for both the path and file system abstractions, raises a new design consideration: should there be both a generic interface for file management and an interface for OS-managed file systems? Each additional interface adds complexity to the library, so it should be avoided unless necssary to achieve other design objectives. One reason that split interfaces may be necessary is because there are operations and semantics that apply to OS files and paths, but not to their generic equivalents. For example, OS-managed files have operations like opening, seeking to a particular location, and closing that may not make sense or be supported by some storage systems. If we exclude those operations from the generic interface, we may violate user's expectations when working with OS-managed files. On the other hand, including them may feel forced and unexpected when working with systems that don't natively support such operations. Ultimately, since the goal was to support the full set of operations available for OS files, I think Go made the right call in separating the interfaces. Whether or not we include both interfaces comes down to how narrow we want the scope of our library to be. For the purposes of this exercise, we will go with the narrower scope and aim for a single generic interface that provides only the essential functionality for managing both OS-managed and generic files.

## Python

Python has three modules in the standard library and four third-party libraries that both beautifully illustrate many of the design considerations we have already discussed and a few new ones. The [`os`](https://docs.python.org/3/library/os.html) module resembles Go in that it provides a low-level interface for OS functionality (including, but not limited to file management) that abstracts over platform differences. The [`shutil`](https://docs.python.org/3/library/shutil.html) module provides a high level interface for working with multiple files (creating and removing directories, moving multiple files, etc.). Providing both a high and low-level interface is a common pattern, but not one that we have come across thus far. The general idea is that a high level interface should make it easy to do _most_ things, while the low level interface gives users maximal control. Whether or not to provide multiple levels of interfaces is another design consideration we will need to address. Finally, the [`pathlib`](https://docs.python.org/3/library/pathlib.html) module provides an object-oriented interface for working OS file paths that abstracts over the differences between Windows and POSIX paths. The interesting thing about `pathlib` is that it provides both a "pure" interface (`PurePath`) that does not contain any methods requiring system calls and an alternative interface (`Path`) that includes all sorts of operations requiring calls to the underlying operating system and can even mutate the data in the file referenced by the path. In this way, the design of the `pathlib` module puts the convenience versus strictness decision back in the hands of the user.

The [cloudpathlib](https://cloudpathlib.drivendata.org/stable/) library extends the Pathlib-style interface to cloud-based storage. The main abstraction is the [`CloudPath`](https://cloudpathlib.drivendata.org/stable/api-reference/cloudpath/), which provides a subset of the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path) functionality relevant for cloud storage. The operations specific to OS files are not part of the interface (e.g. `expanduser`, `is_fifo`, etc.). Users wanting to write portable code can use the [`AnyPath`](https://cloudpathlib.drivendata.org/stable/anypath-polymorphism/) class, which takes a string representing the path as input and returns either a `CloudPath` or `pathlib.Path` instance. In this way, no functionality is lost if you want to use `cloudpathlib` to work with both OS files and generic files. While this approach goes against how we defined paths, files, and filesystems, the interface is likely more familiar than surprising to _python_ users since `pathlib` is part of the standard library.

At the other extreme, the [PyFileSystem2](https://docs.pyfilesystem.org/en/latest/) library avoids surprises by providing an interface that largely conforms to our defintions of paths, files, and file systems. Like NodeJS, `PyFileSystem2` does not have a dedicated `path` abstraction, but provides a module containing path manipulation operations that take paths represented as strings as input. The core abstraction in `PyFileSystem2` is a [`FileSystem`](https://docs.pyfilesystem.org/en/latest/interface.html#interface), which contains all of the operations necessary for managing both files and directories. These operations include all of the standard features, some of the less standard ones that we have seen before like globbing and walking, and some new ones as well. For example, when you construct a `FileSystem` with a given root directory, all subsequent operations are sandboxed such that files outside of the root directory cannot be manipulated. `PyFileSystem2` also provides a few operations that work _across_ storage systems like moving or copying files from the local file system to S3 or vice versa. Once a `FileSystem` is created, it can be used to open and manipulate file data. When you open a file, a [file-like object](https://docs.python.org/3/glossary.html#term-file-like-object) is returned, which is the same thing that happens when you open a local file using the built-in [`open`](https://docs.python.org/3/library/functions.html#open) function in the standard libary. This design choice is intentional and ensures that python users will not be surprised by the interface for file manipulation.

The [smart_open](https://github.com/RaRe-Technologies/smart_open) library takes the idea of extending the built-in `open` function to the extreme. Instead of defining a file system (or other) abstractions, the library provides a single function that returns a file-like-object regardless of the underlying storage system (S3, GCS, Azure Blog Storage, HDFS, etc.). This approach gives users a portable, low-level, interface for manipulating files that matches their expectations. However, it comes at the cost of convenience since many of the essential file-management features we enumerated at the beginning (e.g. directory management) are not provided.

The final third-party library we will discuss is [fsspec](https://filesystem-spec.readthedocs.io/en/latest/index.html), which shares many characteristics with `PyFileSystem2`. In fact, there was a [brief discussion](https://github.com/fsspec/filesystem_spec/issues/5) of combining forces, but the collaboration never materialized. The [interface](https://filesystem-spec.readthedocs.io/en/latest/api.html#fsspec.spec.AbstractFileSystem) aims to feel familiar by closely following the POSIX file system interface, especially with regard to method names and available operations. Like `PyFileSystem2`, the main abstraction is a `FileSystem`, which had different flavors depending on the storage backend. There is no dedicated `path` abstraction or even utilities functions for doing path manipulation. Paths are assumed to be URL-like with a protocol (e.g. `file:///`, `s3://`, etc.) prefixing the remainder of the path, but simple python strings are used. Given the similarity with `PyFileSsytem2`, you may be wondering which to use. From my perspective, they have a similar set of core functionality and supported file systems. If you notice that one or the other has feature(s) that are a must have for you, then I think that is a fair tie breaker. If you are primarily using libraries in the PyData stack, then I'd recommend `fsspec`, since it is deeply connected to that ecosystem.

The various third-party libraries for file management in python raise a few interesting points. First, there is no single best interface because different users may find different design choices surprising. This heterogeneity in what feels surprising is due to difference in users' educational backgrounds, experience with other programming languages, the design of other libraries in the ecosystem. This last point brings us to the second consideration: we cannot discuss an ideal interface without reference to the programming language that will be used for implementation. We already touched on one reason: what the users of a language find surprising is at least partially dependent on the design of other commonly used libraries or packages in that language. The second reason is that different programming languages support different programming styles, so a design based on a programming style that is different from the language used to implement the interface will come across as surprising. For example, if we took a purely object oriented approach to designing our interface, it would come across as surprising when implemented in Python because Python supports both objects and functions as first-class citizens. Instead, an implementation that mixes functions and objects will feel more natural (pythonic) to Python users.

# Ideal Interface

# History

# Tl;Dr

## Definitions

1. **data storage system**: The infrastructure to physically store and manage digital data.
2. **physical storage device**: A hard drive, solid state drive, or other physical device that physicall stores digital data.
3. **filesystem**: The system that manages the access to and manipulation of file data.
4. **file**: A collection of logically-related data.
5. **path**: The _logical_ location of the file within the filesystem.

## Data Storage Taxonomy

There are 5 key differentiators between storage systems:

1. Where data are stored
    - local vs. remote
2. How data are stored
    - block vs. object vs. file
    - flat vs. hierarchical
    - centralized vs. distributed
4. Guarantees
    - strong vs. eventual consistency
5. Semantics
    - file descriptors

[^1]: There are a bunch of variations in how to write out "filesystem". The three most common are `file system`, `file-system`, and `filesystem`. I've opted to use `filesystem` as I think it is the most readable.
[^2]: Not all readers will agree with the taxonomy and definitions that I am laying out in this section. There is quite a bit of variability in how data storage is discussed, so this is merely one attempt to put key terms into a coherent representation. The definitions for file, path, and filesystem play a critical role in later discussions about how to design an ideal interface, so I tried to use definitions that would be the least surprising to most readers. I did this by updating my original definitions based on the following ChatGPT prompt: "What is the difference between a data storage system, filesystem, file, and a path?" My assumption is that the repsonse roughly captures a sort of "average" definition based on what people writing about these terms sees as the distinction between them. For transparency, here are my original definitions and the full ChatGPT response.

    **Original Definitions**

    path: The location of a file within a file system.
    
    file: A collection of logically related pieces of data managed by a filesystem.

    filesystem: The system responsible for managing files and their content.

    data storage system: The system responsible for managing how data are physically stored.

    **Response**

    > A data storage system, file system, file, and path are related concepts but have different meanings:
    >
    > 1. Data storage system: A data storage system is a collection of physical or virtual devices that store digital data, such as hard disk drives, solid-state drives, or cloud storage services. It provides the infrastructure for storing and managing data.
    >
    > 2. File system: A file system is a method for organizing and storing files on a data storage system. It provides a hierarchical structure of directories and files, and includes mechanisms for accessing and manipulating files, such as creating, reading, writing, and deleting files.
    >
    > 3. File: A file is a collection of related information that is stored as a single unit and can be accessed by name. Files can contain any type of data, such as text, images, audio, or video.
    >
    > 4. Path: A path is a string of characters that identifies the location of a file or directory in a file system. It specifies the sequence of directories and subdirectories that must be traversed to reach the file or directory.
    >
    > In summary, a data storage system provides the physical infrastructure for storing digital data, a file system provides the logical structure and mechanisms for organizing and accessing files on a data storage system, a file is a unit of data stored in a file system, and a path is a string of characters that identifies the location of a file or directory within a file system.
[^3]: There are different levels to the notion of where data are stored, but we are interested in only this high-level distinction between local versus remote.
[^4]: The portable operating system interface (POSIX) defines a set of standards to encourage interoperability between operating systems. POSIX defines a hierarchical filesystem and associated API for managing files. Both Windows and at least some Unix-based systems are not fully POSIX compliant, which means that not every local filesystem has the same guarantees and semantics as defined in the POSIX standards.
[^5]: Unix or Unix-like
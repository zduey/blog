---
title: Paths, Files, and Filesystems, Oh My!
author: Zach Duey
date: 2/20/2023
categories:
    - software development
draft: true
toc: true
---

# Introduction

Everyone who writes codes -- software engineers, data engineers, data scientists, etc. -- works with files. Often these files are stored on the user's local machine, but these days, they are just as likely to be stored in remote storage systems like S3, Dropbox, FTP servers, and more. It is common practice to work with files on the local filesystem[^1] for development and debugging purpose and then leverage remote data storage systems when code is running in production. Ideally, this transition would require minimal to no code changes. However, writing portable file management code is complicated by the fact that the libraries for interacting with file-like objects in different storage systems have wildly differing interfaces and functionality. As with most problems in computer science, one solution is to introduce a layer of abstraction; in this case, a generic filesystem interface.

In this post, we will work towards designing a filesystem interface that satisfies these three core requirements. This is largely a pedagogical exercise designed to both learn about file management topics and the challenge of constructing a well-designed interface. For more details about why I am writing this post and how it developed, check out the [history](#history) section. If you are short on time, check out the [tl;dr](#tldr) version.

A generic filesystem interface has three essential features. First, it must be flexible enough to abstract over the underlying differences between data storage systems. Second, it must include all essential filesystem management operations. Finally, it should adhere to the principle of least surprise: most users should find the interface intuitive.

First, we will cover some [background material](#background) about data storage systems and associated concepts. Second, we will enumerate the [essential operations](#essential-operations) that our interface must include. Third, we will take a look at [existing solutions](#prior-art) to the problem. Finally, we will provide a sketch of our [ideal interface](#ideal-interface).

# Background

Data storage is a broad topic that is far beyond the scope of this post, so we will focus on a few key terms and related topics[^2] necessary to design a generic filesystem interface.

A **data storage system** provides the infrastructure to store and manage digital data. A **physical storage device** is the hardware component of this system. Hard drives, solid state drives, flash drives, and SD cards are all examples of physical storage devices. A **filesystem** manages access to and manipulation of data associated with files. A **file** is a collection of _logically_ related data. The data associated with the file may be physically dispersed on the underlying physical storage device. In this way, a file is an abstraction provided by many data storage systems that hides the messy details of exactly how and where the data are stored from the user of that data. A **path** is the _logical_ location of the file within the filesystem. Like a file, a path is an abstraction provided by the system to shield the user of the system from details that are not their concern. Finally, I will abuse terminology a bit and use the term **storage system** to refer to any combination of these elements. With our working definitions laid out, we can now take a look as some of the characteristics that distinguish different storage systems. Ultimately, our interface must be able to abstract away these difference, so understanding them at least at a high level is essential.

The most important difference between storage systems, at least for our purpses, has to do with whether data are stored locally or remotely[^3]. A **local data storage system** persists data on a physical storage device that is _physically_ connected to an individual's computer. In contrast, a **remote data storage system** persists data on a physical storage device that is accessible from, but not physically connected to, an individual's computer. In a remote data storage system, an external computer used to access the system is called a **client**. There are a plethora of remote storage systems that fall into this category including Network Attached Storage (NAS), Dropbox, OneDrive, Box, Google Drive, and many more. One thing that each of these systems have in common is that, to the client, files can be stored and accessed in a similar way as files on the local filesystem. Some remote storage systems even provide a way to _mount_ the filesystem onto the local filesystem such that accessing and managing files on the remote system is identical to working with local files. However, other remote data storage systems do not maintain the same logical similarity to the local storage system: FTP servers and cloud-based blob storage (e.g. S3) are two examples. 

The second differentiator between storage systems revolves around _how_ data are stored. There are three aspects to how data are stored that we will consider: type of data storage, the organizational structure of the filesystem, and whether storage is centalized or distributed.

There are three main types of data storage: file , object, and block storage. The methods used to store and access data for each type of storage system are optimized for different purposes. For example, they differ in how logically-related data are arranged on the underlying physical storage device(s).manifested in how the system physically arranges logically-related data on the underlying physical storage device. **Block storage** is most commonly used for storing data in relational database systems. **Object storage** is frequently used in cloud storage systems like AWS S3, Azure Blob Storage, and GCP object storage. **File storage** is the most common type of storage as it is used for individual computers and the kinds of remote storage systems used by typical consumers (e.g. Dropbox, Box, OneDrive, Google Drive, etc.). We will focus on file and object storage systems as both allow access to logically-related data through file-like objects. One of the challenges we will face in designing our system is ensuring that it abstracts over the differences between these two types of systems in a way that feels both familiar and does not neglect any essential features.

The second way that storage systems diverge is around the _logical_ organizational structure used. The two main types of organizational structures are hierarchical and flat. A **hierarchical organizational structure** introduces an additional abstraction called a directory (or folder), which is a logical container that may contain other directories or files. The vast majority of storage systems leverage a hierarchical organizational structure. In contrast, a **flat organizational structure** keeps all files at a single logical level with the file name used to differentiate objects. Object storage (e.g. AWS S3) often appears to be hierarchical (e.g. directories or folder creation are supported) from the provided UIs, but typically use a flat organizational structure under the hood.

Third, data storage systems may be centralized or distributed. A **centralized data storage system** persists file data in a single physical location. A system that replicates data across multiple physical storage devices connected to a single server is still a centralized data storage system (e.g. single server with physical storage devices arranged in a RAID configuration). In contrast, a **distributed data storage system** stores data on multiple machines. Cloud-based object storage, the Hadoop Distributed File System (HDFS), and many others are distributed storage systems. It is not always the case that remote storage systems are distributed and local storage systems are centralized. For example, an FTP server is a remote data storage system that is also centralized system.

The third differentiator between storage systems has to do with the guarantees offered by the associated filesystem. Many filesystems allow data to be accessed concurrently (via threads, processes, or multiple client machines) and guarantee strong consistency, which means that any read operation will return the latest data. For example, both S3 and POSIX-compatible filesystems[^4] offer strong consistency guarantees. However, some distributed storage system offer a weaker guarantee called eventual consistency. The difference between consistency or other types of guarantees is not important. For our purposes, what is important is that our interface hides these differences from the user.

The final differentiator between storage systems involves filesystem semantics. I am abusing the term "semantics" a bit, so let me expalin what I mean by way of an example. On a single computer, the local filesystem is itself managed by the host operating system. However, the filesystem component of many data storage systems are not managed by a host operating system. These operating-system managed files (OS files) involve concepts (semantics) that are not shared by all storage systems. For example, on many *Nix[^5] systems, OS files are managed via a file descriptors, which is a unique identifier for a file. Other data storage systems like AWS S3, Dropbox, and others do not have similar constructs and therefore, it would be weird to impose the semantics of file descriptors on all storage systems supported by our interface. Our interface should support managing both types of files (generic and OS) without imposing the semantics associated with one onto the other.

To make things concrete, @tbl-classification uses the taxonomy that we have just developed to classify the main storage systems that our interface should support. For example, the table says that a local file system is hierarchical, centralized, offers strong consistency, and uses the semantics typically associated with OS files (e.g. file descriptors).

| **Storage System** | **Where** | **Type** | **Organizational Structure** | **Distribution** | **Guarantees**     | **Semantics**    |
|--------------------|-----------|----------|------------------------------|------------------|--------------------|------------------|
| Local Filesystem   | Local     | File     | Hierarchical                 | Centralized      | Strong consistency | File descriptors |
| AWS S3             | Remote    | Blob     | Flat                         | Distributed      | Strong consistency |                  |
| Azure Blob Storage | Remote    | Blob     | Flat                         | Distributed      | Strong consistency |                  |
| GCP GCS            | Remote    | Blob     | Flat                         | Distributed      | Strong consistency |                  |
| Tar                | Local     | File     | Hierarchical                 | Centralized      | Strong consistency |                  |
| Zip                | Local     | File     | Hierarchical                 | Centralized      | Strong consistency |                  |
| HDF5               | Local     | File     | Hierarchical                 | Centralized      | Strong consistency | Metadata         |
| SFTP               | Remote    | File     | Hierarchical                 | Centralized      | Strong consistency |                  |
| Dropbox            | Remote    | File     | Hierarchical                 | Distributed      | Strong Consistency |                  |
| Box                | Remote    | File     | Hierarchical                 | Distributed      | Strong Consistency |                  |
| Google Drive       | Remote    | File     | Hierarchical                 | Distributed      | Strong Consistency |                  |

: Data Storage System Classification {#tbl-classification}

Now that we have a sense of how to talk about different storage systems and a mostly-complete listing of the types of stystems we would like our interface to support, we can enumerate the essential operations that the interface must provide.

# Essential Operations

Our goal of writing portable file management code coupled with the desire to adhere to the principal of least surprise will guide us in deciding what operations are essential to a generic filesystem interface. In a later [section](#ideal-interface), we will delve into more detail about the abstraction(s), to which, each operations should belong. For now, we will consider three core entities and the kinds of operations that are relevant to each: files, paths, and directories[^6].

## Files

There are the 4 essential file management operations:

1. Create
2. Read
3. Write
4. Delete

This list has a few notable omissions:

1. Update
2. Move
3. Rename
4. Copy
5. Partial read
6. Partial write
7. Permissions management
8. Metadata inspection

The first 4 operations were left off because each operation can be accomplished by reading file data into a temporary location, manipulating the data, createing a new file, writing the data to the new file, and deleting the old file. The next two can also be accomplished using the four essential operations, albeit following a slightly different recipe. Permissions management is a category of operations involving both inspecting and modifying which users and groups have which level of permission (read, write, etc.). Metadata inspection is another category of operations to do things like inspecting at the size of the file, last update time, created time, etc. While every storage system has some notion of permissions and metadata, the exact semantics vary. None of these 6 operations are strictly essential, but it would probably surprise most users to exclude them from the interface. In deference to the principle of least surprise, we will need to include them in the interface.

## Directories

Although not every storage system is hierarachical, all of the ones that we are considering provide users with the ability to work with directory-like entities and therefore, we we will consider which operations related to directory management are essential. We could consider defining a core interface and an optional interface specific to hierarchical storage systems, but we will consider that an implementation detail and defer further discussion to [later](#ideal-interface).

There are three essential directory management operations:

1. Create
2. Read (list contents)
3. Delete (can be recursive)

This is the same set of essential operations as file management, except for the update operation, which is unnecessary. Since directories are simply containers for files and other directories, updating happens via operations to the sub-directories and files inside of the directory. Much like for file manipulation, there are also a few non-essnetial operations: 

1. Move
2. Copy

To avoid unnecessary surprises, these will also need to be included in the interface.

## Path

The last core entity we will consider is a path, which we defined previously as the location of a file in a filesystem. In most programming languages, paths can be represented by a string (or equivalent data type), which means that they are not strictly a core entity. Unfortunately, the principle of least surprise does not offer concrete guidance. Whether or not a user expects paths to have dedicated operations likely depends on their past experience manipulating paths in one or more programming languages. For the purposes of this section, we will assume that users expect certain convenience operations that operate on paths and defer a decision about whether to include them as part of a separate entity to [later](#ideal-interface).

There are 4 convenience operations for either inspecting or manipulating paths that I anticipate most users would expect:[^7] 

1. Inspect individual components (stem, root, filename, etc.)
2. Parse into or iterate over path components
3. Join two or more paths
4. Normalize/Standardize/Canonicalize

Now that we have covered the eseential operations for our three core entities, we can start to get a sense of how we might design our interface by looking at the design of file management libraries provided by different programming languages.

# Prior Art

In this section, we will take a brief tour of file management interfaces in Rust, NodeJS, Go, and Python. While this list is far from exhaustive, the standard and third-party file management libraries available across these langauges provide an informative set of contrasts that illuminate many of the critical considerations involved in designing a generic file management interface. To guide our exploration, we will focus on the following questions:

1. How are the file management related components organized?
2. What core abstractions does the library provide?
3. How are these abstractions related to one another?
4. To which abstraction(s) are the essential operations associated?
5. What design decisions does the interface surface?
6. How are these design decisions related to the ones made in other libraries?

### Rust

File management operations in the Rust standard library are limited to OS files and are split among two modules: [`std::fs`](https://doc.rust-lang.org/std/fs/index.html#) and [`std::path`](https://doc.rust-lang.org/std/path/index.html). These modules contain two core abstractions (`Path` and `File`) and one implicit abstraction (filesystem) implemented as a set of operations associated with the `fs` module.

A [`std::path::Path`](https://doc.rust-lang.org/beta/std/path/struct.Path.html) is an immutable reference to an OS file. It can be constructed from a string, abstracts over differences between Unix and Windows path representations, and provides all of the 4 essential operations for both manipulating the path and inspecting its components.

While the `Path` interface does not provide any methods for _manipulating_ the underlying file, it does provide a number of methods for _inspecting_ it, all of which result in calls to the operating system (e.g. `exists`, `is_dir`, and `read_link` to name just a few). Although these methods are convenient, they go against the implementation implied by our definition, in which a path had no management responsibilities or knowledge of the file it references.

The design of the `Path` interface in Rust brings us to our first design consideration: the tradeoff between convenience and surprise. The closer our interfaces stick to the definitions outlined earlier, the less surprising it will be. However, strict conformity to our definitions comes at the expense of convenience: switching between abstractions to perform operations is less convenient than performing the same set of operations using a single (or fewer) abstraction. While the requirement that the interface be unsurprising does not preclude making some decisions in favor of convenience, it does push us to favor fairly strict adherence to the definitions. We will see this tradeoff come up again and again as we continue our tour of file management interfaces.

The [`std::fs`](https://doc.rust-lang.org/std/fs/index.html) module serves as both a filesystem abstraction and container for other abstractions supporting file management. The module-level functions include operations for managing files, directories, and their associated permissions. While some of these operations are unique, others overlap with the methods attached to other abstractions. Only the `fs` module includes operations for copying, renaming, and removing files. It is also the module solely responsible for directory management operations. Both [`std::fs::File`](https://doc.rust-lang.org/beta/std/fs/struct.File.html) and `fs` have the ability to manage file data as well as permissions. The data manipulation functionality associated with `fs` is limited to entire contents of the file, whereas the `File` abstraction allows for reading and writing to aribtrary locations. There is also overlap in functionality between the `fs` module and the `Path` abstraction: `canonicalize`, `try_exists`, `read_link`, `read_dir`, and `symlink_metadata` are all equivalent operations available through both abstractions.

Our exploration of the file management abstractions in Rust raises our second design consideration: to what extent should different abstractions have overlapping operations? On the one hand, strict adherence to our definitions of files, paths, and filesystems suggests that each has distinct, non-overlapping operations. On the other, having overlapping functionality may simplify certain tasks by requiring fewer abstractions. This is reminiscent of the convenience vs. surprise tradeoff noted earlier, but we will treat it as a separate consideration because it is a more specific instance of that broader consideration.

## Nodejs

File managment in NodeJS shares many similarities with Rust, but offers two insightful differences: the file system acccepts URLs in addition to file paths, and paths are handled in a totally different way. The two modules relevant to our discussion are [`fs`](https://nodejs.org/api/fs.html) and [`path`](https://nodejs.org/api/path.html)). While the similarities between Rust and NodeJS are interesting, we will foucs our attention on their differences in order to avoid recapitulating the design considerations we have previously discussed.

Nodejs takes a very different approach to paths, which can be condensed into two main differences. First, Nodejs does not have a dedicated `Path` abstraction; instead, the `path` module provides a functional interface that offers a similar set of operations as the `Path` abstraction in Rust. For example, the properties (directory, root, base, name, and extenion) associated with paths are accessed by [parsing](https://nodejs.org/api/path.html#pathparsepath) the string representation of the path. Canonicalizig, normalizing, combining, and other path operations are all performed via functions that take a base path as the first argument. In some ways, this is more of a stylistic difference than a major design consideration. In any programming language that supports both functions and classes as first-class citizens, it is often possible to replace a class with a collection of functions sharing the same first argument. Likewise, a collection of functions operating on the same entity can be conversted into a class with a corresponding set of methods. As a rule of thumb, I prefer pure functions over stateful classes and will reach for a class when doing so offers something that is either not possible with functions, or is unwieldy. In this particular case, the NodeJS design raises the question: is a separate `Path` abstraction necessary? We will leave any further consideration to later when get get arond to designing our interface. The second difference between NodeJS and Rust is more consequential. Unlikke Rust, the NodeJS `path` module does not include any operations that result in calls to the underlying operating system. This implementation is closer to the one implied by our definition of a path and can therefore be seen as yet another manifestation of the convenience vs. surprise tradeoff. In fact, this tradeoff underlies all of our design decisions around which operations to associate with which abstractions.

The most interesting feature of the NodeJS `fs` module relative to Rust is that NodeJS supports providing file names as either a string or `URL` (via the `file:///` syntax). While this may seem surprising at first glance, both URLs and paths represent the location of a resource, and are therefore logically similar. This feature of NodeJS raises two interesting questions. First, should our file management interface support paths represented as URLs? Since URLs can encode more information than paths (protocol, query parameters, basic authentication, etc.), one can make the case that URLs should not be supported, and instead users should be required to convert their URL to a path (or string, depending on our other design decisions). Second, should static web servers be consider another hierarchical data storage system? Neither of these questions are necessarily new design considerations; however, both surface potential features of our library.

## Go

Go is the only programming language that we will discuss that addressses the distinction between generic files and files managed by an operating system. In Go, this distinction is present in both the path and file system abstractions. A generic [path](https://pkg.go.dev/path) is a reference to a location. Generic paths are marked by the use of forward slashes to separate components, which means URLs are natively supported. None of the operations in the `path` package require calls to the underlying storage system. The functionality for working with OS paths lives in the [path.filepath](https://pkg.go.dev/path/filepath) package. This package offers all of the same operations as the `path` package, plus some additional OS path specific operations. Much like the `path` package in Rust, the `path.filepath` package includes a few operations that require calls to the underlying operating system. Two of these operations are also new for us: globbing, and walking. Globbing refers to an operation that searches a given directory for any files matching a particular pattern. Walking involves navigating a file tree and performing some user-defined operation each time a directory or file is encountered. These two operations are features that are worth considering adding to our library, although, we will need to decide -- like all other operations -- which abstraction(s) they should be associated with. Go elects to add them to both the path and file system abstractions.

The file system abstraction in Go is also divided into the [`os`](https://pkg.go.dev/os) package for OS-managed files and the [`fs`](https://pkg.go.dev/io/fs) package for generic file system management. The two packages have many overlapping pieces of functionality, although the `os` package contain additional functionality beyond file mmanagement.

The split interfaces,for both the path and file system abstractions, raises a new design consideration: should there be both a generic interface for file management and an interface for OS-managed file systems? Each additional interface adds complexity to the library, so it should be avoided unless necssary to achieve other design objectives. One reason that split interfaces may be necessary is because there are operations and semantics that apply to OS files and paths, but not to their generic equivalents. For example, OS-managed files have operations like opening, seeking to a particular location, and closing that may not make sense or be supported by some storage systems. If we exclude those operations from the generic interface, we may violate user's expectations when working with OS-managed files. On the other hand, including them may feel forced and unexpected when working with systems that don't natively support such operations. Ultimately, since the goal was to support the full set of operations available for OS files, I think Go made the right call in separating the interfaces. Whether or not we include both interfaces comes down to how narrow we want the scope of our library to be. For the purposes of this exercise, we will go with the narrower scope and aim for a single generic interface that provides only the essential functionality for managing both OS-managed and generic files.

## Python

Python has three modules in the standard library and four third-party libraries that both beautifully illustrate many of the design considerations we have already discussed and a few new ones. The [`os`](https://docs.python.org/3/library/os.html) module resembles Go in that it provides a low-level interface for OS functionality (including, but not limited to file management) that abstracts over platform differences. The [`shutil`](https://docs.python.org/3/library/shutil.html) module provides a high level interface for working with multiple files (creating and removing directories, moving multiple files, etc.). Providing both a high and low-level interface is a common pattern, but not one that we have come across thus far. The general idea is that a high level interface should make it easy to do _most_ things, while the low level interface gives users maximal control. Whether or not to provide multiple levels of interfaces is another design consideration we will need to address. Finally, the [`pathlib`](https://docs.python.org/3/library/pathlib.html) module provides an object-oriented interface for working OS file paths that abstracts over the differences between Windows and POSIX paths. The interesting thing about `pathlib` is that it provides both a "pure" interface (`PurePath`) that does not contain any methods requiring system calls and an alternative interface (`Path`) that includes all sorts of operations requiring calls to the underlying operating system and can even mutate the data in the file referenced by the path. In this way, the design of the `pathlib` module puts the convenience versus strictness decision back in the hands of the user.

The [cloudpathlib](https://cloudpathlib.drivendata.org/stable/) library extends the Pathlib-style interface to cloud-based storage. The main abstraction is the [`CloudPath`](https://cloudpathlib.drivendata.org/stable/api-reference/cloudpath/), which provides a subset of the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path) functionality relevant for cloud storage. The operations specific to OS files are not part of the interface (e.g. `expanduser`, `is_fifo`, etc.). Users wanting to write portable code can use the [`AnyPath`](https://cloudpathlib.drivendata.org/stable/anypath-polymorphism/) class, which takes a string representing the path as input and returns either a `CloudPath` or `pathlib.Path` instance. In this way, no functionality is lost if you want to use `cloudpathlib` to work with both OS files and generic files. While this approach goes against how we defined paths, files, and filesystems, the interface is likely more familiar than surprising to _python_ users since `pathlib` is part of the standard library.

At the other extreme, the [PyFileSystem2](https://docs.pyfilesystem.org/en/latest/) library avoids surprises by providing an interface that largely conforms to our defintions of paths, files, and file systems. Like NodeJS, `PyFileSystem2` does not have a dedicated `path` abstraction, but provides a module containing path manipulation operations that take paths represented as strings as input. The core abstraction in `PyFileSystem2` is a [`FileSystem`](https://docs.pyfilesystem.org/en/latest/interface.html#interface), which contains all of the operations necessary for managing both files and directories. These operations include all of the standard features, some of the less standard ones that we have seen before like globbing and walking, and some new ones as well. For example, when you construct a `FileSystem` with a given root directory, all subsequent operations are sandboxed such that files outside of the root directory cannot be manipulated. `PyFileSystem2` also provides a few operations that work _across_ storage systems like moving or copying files from the local file system to S3 or vice versa. Once a `FileSystem` is created, it can be used to open and manipulate file data. When you open a file, a [file-like object](https://docs.python.org/3/glossary.html#term-file-like-object) is returned, which is the same thing that happens when you open a local file using the built-in [`open`](https://docs.python.org/3/library/functions.html#open) function in the standard libary. This design choice is intentional and ensures that python users will not be surprised by the interface for file manipulation.

The [smart_open](https://github.com/RaRe-Technologies/smart_open) library takes the idea of extending the built-in `open` function to the extreme. Instead of defining a file system (or other) abstractions, the library provides a single function that returns a file-like-object regardless of the underlying storage system (S3, GCS, Azure Blog Storage, HDFS, etc.). This approach gives users a portable, low-level, interface for manipulating files that matches their expectations. However, it comes at the cost of convenience since many of the essential file-management features we enumerated at the beginning (e.g. directory management) are not provided.

The final third-party library we will discuss is [fsspec](https://filesystem-spec.readthedocs.io/en/latest/index.html), which shares many characteristics with `PyFileSystem2`. In fact, there was a [brief discussion](https://github.com/fsspec/filesystem_spec/issues/5) of combining forces, but the collaboration never materialized. The [interface](https://filesystem-spec.readthedocs.io/en/latest/api.html#fsspec.spec.AbstractFileSystem) aims to feel familiar by closely following the POSIX file system interface, especially with regard to method names and available operations. Like `PyFileSystem2`, the main abstraction is a `FileSystem`, which had different flavors depending on the storage backend. There is no dedicated `path` abstraction or even utilities functions for doing path manipulation. Paths are assumed to be URL-like with a protocol (e.g. `file:///`, `s3://`, etc.) prefixing the remainder of the path, but simple python strings are used. Given the similarity with `PyFileSsytem2`, you may be wondering which to use. From my perspective, they have a similar set of core functionality and supported file systems. If you notice that one or the other has feature(s) that are a must have for you, then I think that is a fair tie breaker. If you are primarily using libraries in the PyData stack, then I'd recommend `fsspec`, since it is deeply connected to that ecosystem.

The various third-party libraries for file management in python raise a few interesting points. First, there is no single best interface because different users may find different design choices surprising. This heterogeneity in what feels surprising is due to difference in users' educational backgrounds, experience with other programming languages, the design of other libraries in the ecosystem. This last point brings us to the second consideration: we cannot discuss an ideal interface without reference to the programming language that will be used for implementation. We already touched on one reason: what the users of a language find surprising is at least partially dependent on the design of other commonly used libraries or packages in that language. The second reason is that different programming languages support different programming styles, so a design based on a programming style that is different from the language used to implement the interface will come across as surprising. For example, if we took a purely object oriented approach to designing our interface, it would come across as surprising when implemented in Python because Python supports both objects and functions as first-class citizens. Instead, an implementation that mixes functions and objects will feel more natural (pythonic) to Python users.

# Ideal Interface

# History

# Tl;Dr

## Definitions

1. **data storage system**: The infrastructure to physically store and manage digital data.
2. **physical storage device**: A hard drive, solid state drive, or other physical device that physicall stores digital data.
3. **filesystem**: The system that manages the access to and manipulation of file data.
4. **file**: A collection of logically-related data.
5. **path**: The _logical_ location of the file within the filesystem.

## Data Storage Taxonomy

There are 4 key differentiators between storage systems:

1. Where data are stored
    - local vs. remote
2. How data are stored
    - block vs. object vs. file
    - flat vs. hierarchical
    - centralized vs. distributed
3. Guarantees
    - strong vs. eventual consistency
4. Semantics
    - file descriptors

[^1]: There are a bunch of variations in how to write out "filesystem". The three most common are `file system`, `file-system`, and `filesystem`. I've opted to use `filesystem` as I think it is the most readable.
[^2]: Not all readers will agree with the taxonomy and definitions that I am laying out in this section. There is quite a bit of variability in how data storage is discussed, so this is merely one attempt to put key terms into a coherent representation. The definitions for file, path, and filesystem play a critical role in later discussions about how to design an ideal interface, so I tried to use definitions that would be the least surprising to most readers. I did this by updating my original definitions based on the following ChatGPT prompt: "What is the difference between a data storage system, filesystem, file, and a path?" My assumption is that the repsonse roughly captures a sort of "average" definition based on what people writing about these terms sees as the distinction between them. For transparency, here are my original definitions and the full ChatGPT response.

    **Original Definitions**

    path: The location of a file within a file system.
    
    file: A collection of logically related pieces of data managed by a filesystem.

    filesystem: The system responsible for managing files and their content.

    data storage system: The system responsible for managing how data are physically stored.

    **Response**

    > A data storage system, file system, file, and path are related concepts but have different meanings:
    >
    > 1. Data storage system: A data storage system is a collection of physical or virtual devices that store digital data, such as hard disk drives, solid-state drives, or cloud storage services. It provides the infrastructure for storing and managing data.
    >
    > 2. File system: A file system is a method for organizing and storing files on a data storage system. It provides a hierarchical structure of directories and files, and includes mechanisms for accessing and manipulating files, such as creating, reading, writing, and deleting files.
    >
    > 3. File: A file is a collection of related information that is stored as a single unit and can be accessed by name. Files can contain any type of data, such as text, images, audio, or video.
    >
    > 4. Path: A path is a string of characters that identifies the location of a file or directory in a file system. It specifies the sequence of directories and subdirectories that must be traversed to reach the file or directory.
    >
    > In summary, a data storage system provides the physical infrastructure for storing digital data, a file system provides the logical structure and mechanisms for organizing and accessing files on a data storage system, a file is a unit of data stored in a file system, and a path is a string of characters that identifies the location of a file or directory within a file system.
[^3]: There are different levels to the notion of where data are stored, but we are interested in only this high-level distinction between local versus remote.
[^4]: The portable operating system interface (POSIX) defines a set of standards to encourage interoperability between operating systems. POSIX defines a hierarchical filesystem and associated API for managing files. Both Windows and at least some Unix-based systems are not fully POSIX compliant, which means that not every local filesystem has the same guarantees and semantics as defined in the POSIX standards.
[^5]: Unix or Unix-like
[^6]: Although not all storage systems are hierarchical, directories are included in this list because all of the storage systems that we are interested in at least give the appearance of supporting directories.
[^7]: Pythonistas will notice that this list is heavily influence by the interface for [`pathlib.PurePath`](https://docs.python.org/3/library/pathlib.html#pure-paths), which betrays my own background primarily writing code in Python.
